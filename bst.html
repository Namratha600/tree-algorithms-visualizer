<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BST Visualizer</title>

<style>
body {
    margin: 0;
    font-family: "Poppins", sans-serif;
    background: linear-gradient(135deg, #c1dfc4, #deecdd);
    color: #134e4a;
    text-align: center;
}

h1 {
    font-size: 44px;
    margin: 20px 0 10px;
    color: #064e3b;
}

h1 span {
    font-size: 48px;
}

.controls {
    background: #ffffffcc;
    padding: 20px;
    border-radius: 20px;
    width: 85%;
    margin: auto;
    box-shadow: 0 10px 25px rgba(0,0,0,0.15);
}

input {
    width: 220px;
    padding: 16px;
    font-size: 20px;
    border-radius: 16px;
    border: 2px solid #34d399;
    margin: 10px;
}

button {
    padding: 16px 26px;
    font-size: 18px;
    border-radius: 20px;
    border: none;
    margin: 10px;
    cursor: pointer;
    background: linear-gradient(135deg, #34d399, #059669);
    color: white;
    font-weight: bold;
    transition: 0.3s;
}

button:hover {
    transform: scale(1.08);
    box-shadow: 0 6px 18px rgba(0,0,0,0.25);
}

svg {
    width: 100%;
    height: 480px;
    margin-top: 20px;
}

.node {
    fill: #10b981;
    stroke: #064e3b;
    stroke-width: 3;
}

.node.active { fill: #f59e0b; }
.node.done { fill: #6366f1; }

text {
    fill: white;
    font-size: 20px;
    font-weight: bold;
}

line {
    stroke: #065f46;
    stroke-width: 3;
    marker-end: url(#arrow);
}

#traversalBox {
    background: #ffffffcc;
    border-radius: 20px;
    padding: 20px;
    width: 85%;
    margin: 20px auto;
    box-shadow: 0 10px 25px rgba(0,0,0,0.15);
}

.circle {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: #34d399;
    color: white;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    margin: 6px;
    font-weight: bold;
}

.trArrow {
    font-size: 28px;
    font-weight: bold;
    color: #065f46;
    margin: 0 6px;
}

#complexity {
    font-size: 20px;
    margin-top: 10px;
    color: #065f46;
    font-weight: bold;
}
</style>
</head>

<body>

<h1><span>ðŸŒ³</span> Binary Search Tree Visualizer</h1>

<div class="controls">
    <input type="number" id="value" placeholder="Enter value">
    <button onclick="insert()">Insert</button>
    <button onclick="deleteValue()">Delete</button><br>

    <button onclick="inorder()">Inorder</button>
    <button onclick="preorder()">Preorder</button>
    <button onclick="postorder()">Postorder</button>
    <button onclick="levelorder()">Level Order</button>
</div>

<svg id="tree">
<defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto">
        <path d="M0,0 L0,6 L9,3 z" fill="#065f46"/>
    </marker>
</defs>
</svg>

<div id="traversalBox">
    <h2 id="traversalTitle">Traversal Output</h2>
    <div id="output"></div>
    <div id="complexity"></div>
</div>

<script>
class Node {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
        this.el = null;
    }
}

let root = null;
let svg = document.getElementById("tree");
let nodeCount = 0;

/* ===== INSERT WITH PARENT BLINKING + DUPLICATE CHECK ===== */
async function insert() {
    let v = parseInt(value.value);
    if (isNaN(v)) return;

    if (!root) {
        root = new Node(v);
        nodeCount++;
        redraw();
        return;
    }

    let cur = root;
    while (true) {
        cur.el.classList.add("active");
        await sleep(500);
        cur.el.classList.remove("active");

        /* ðŸ”´ DUPLICATE CHECK (ONLY NEW FEATURE) */
        if (v === cur.val) {
            alert("Duplicates are not allowed in BST");
            return;
        }

        if (v < cur.val) {
            if (!cur.left) {
                cur.left = new Node(v);
                break;
            }
            cur = cur.left;
        } else {
            if (!cur.right) {
                cur.right = new Node(v);
                break;
            }
            cur = cur.right;
        }
    }

    nodeCount++;
    redraw();
}

/* ===== DELETE ===== */
function deleteValue() {
    let v = parseInt(value.value);
    if (isNaN(v)) return;
    root = deleteRec(root, v);
    nodeCount = Math.max(0, nodeCount - 1);
    redraw();
}

function deleteRec(node, v) {
    if (!node) return null;
    if (v < node.val) node.left = deleteRec(node.left, v);
    else if (v > node.val) node.right = deleteRec(node.right, v);
    else {
        if (!node.left) return node.right;
        if (!node.right) return node.left;
        let s = minValue(node.right);
        node.val = s.val;
        node.right = deleteRec(node.right, s.val);
    }
    return node;
}

function minValue(n) {
    while (n.left) n = n.left;
    return n;
}

/* ===== DRAW TREE ===== */
function redraw() {
    svg.innerHTML = svg.querySelector("defs").outerHTML;
    drawRec(root, window.innerWidth / 2, 60, window.innerWidth / 4);
}

function drawRec(node, x, y, gap) {
    if (!node) return;
    node.x = x;
    node.y = y;

    if (node.left) {
        drawLine(x, y, x - gap, y + 80);
        drawRec(node.left, x - gap, y + 80, gap / 2);
    }
    if (node.right) {
        drawLine(x, y, x + gap, y + 80);
        drawRec(node.right, x + gap, y + 80, gap / 2);
    }
    drawNode(node);
}

function drawNode(node) {
    let g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    let c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    let t = document.createElementNS("http://www.w3.org/2000/svg", "text");

    c.setAttribute("cx", node.x);
    c.setAttribute("cy", node.y);
    c.setAttribute("r", 30);
    c.classList.add("node");

    t.setAttribute("x", node.x);
    t.setAttribute("y", node.y + 7);
    t.setAttribute("text-anchor", "middle");
    t.textContent = node.val;

    g.appendChild(c);
    g.appendChild(t);
    svg.appendChild(g);
    node.el = c;
}

function drawLine(x1, y1, x2, y2) {
    let l = document.createElementNS("http://www.w3.org/2000/svg", "line");
    l.setAttribute("x1", x1);
    l.setAttribute("y1", y1 + 30);
    l.setAttribute("x2", x2);
    l.setAttribute("y2", y2 - 30);
    svg.appendChild(l);
}

/* ===== TRAVERSALS ===== */
function reset() {
    document.querySelectorAll(".node").forEach(n => n.classList.remove("active","done"));
    output.innerHTML = "";
}

async function visit(n) {
    n.el.classList.add("active");
    await sleep(500);
    n.el.classList.remove("active");
    n.el.classList.add("done");

    let d = document.createElement("div");
    d.className = "circle";
    d.innerText = n.val;
    output.appendChild(d);

    let a = document.createElement("span");
    a.className = "trArrow";
    a.innerText = "â†’";
    output.appendChild(a);
}

async function inorder() {
    reset();
    traversalTitle.innerText = "Inorder Traversal";
    showComplexity("Inorder");
    await inorderRec(root);
}
async function inorderRec(n) {
    if (!n) return;
    await inorderRec(n.left);
    await visit(n);
    await inorderRec(n.right);
}

async function preorder() {
    reset();
    traversalTitle.innerText = "Preorder Traversal";
    showComplexity("Preorder");
    await preorderRec(root);
}
async function preorderRec(n) {
    if (!n) return;
    await visit(n);
    await preorderRec(n.left);
    await preorderRec(n.right);
}

async function postorder() {
    reset();
    traversalTitle.innerText = "Postorder Traversal";
    showComplexity("Postorder");
    await postorderRec(root);
}
async function postorderRec(n) {
    if (!n) return;
    await postorderRec(n.left);
    await postorderRec(n.right);
    await visit(n);
}

async function levelorder() {
    reset();
    traversalTitle.innerText = "Level Order Traversal";
    showComplexity("Level Order");
    let q = [root];
    while (q.length) {
        let n = q.shift();
        if (!n) continue;
        await visit(n);
        q.push(n.left, n.right);
    }
}

/* ===== COMPLEXITY ===== */
function showComplexity(type) {
    complexity.innerHTML =
        `Time Complexity of <b>${type}</b> Traversal: <b>O(n)</b><br>
         where <b>n = ${nodeCount}</b> (number of nodes)`;
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}
</script>

</body>
</html>